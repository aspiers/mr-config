# -*- mode: sh -*-

lib =
    MR_GIT=$HOME/.GIT
    GIT_MY_ROOT=$MR_GIT/adamspiers.org
    MY_UPSTREAM_HOST=git.adamspiers.org
    #GIT_MY_UPSTREAM_HOME=ssh://$MY_UPSTREAM_HOST/home/adam/
    GIT_MY_UPSTREAM_HOME=arctic:
    GIT_MY_UPSTREAM=${GIT_MY_UPSTREAM_HOME}.GIT/adamspiers.org
    GIT_UPSTREAM_ROOT=$MR_GIT/3rd-party
    #
    check_repo_name () {
        [ -n "$MR_NAME" ] || error "\$MR_NAME not set for $MR_REPO"
    }
    #
    git_email () {
        cd "$MR_REPO"
        if ! work_repo; then
            git_set_personal_email "$@"
            return 0
        fi
        #
        if [ -n "$1" ]; then
            error "Invoked 'git_email $1' on work repository $MR_REPO"
        fi
        git_set_email aspiers@suse.com
    }
    git_set_personal_email () {
        email="${1:-${MR_EMAIL:-$MR_NAME}}"
        case "$email" in
            *@*) ;;
            *) email="$email@adamspiers.org"
        esac
        git_set_email "$email"
    }
    git_set_email () {
        email="$1"
        existing=$( git config user.email || true )
        if [ "$email" != "$existing" ]; then
            git config user.email "$email"
            info "Set user.email from ${existing:-(none)} to $email"
        fi
    }
    #
    git_clone () {
        check_repo_name
        info "Cloning from $1"
        remote_opt=
        if [ -n "$MR_GIT_REMOTE" ]; then
            remote_opt="-o $MR_GIT_REMOTE"
            echo "Default remote is $MR_GIT_REMOTE"
        fi
        branch_opt=
        if [ -n "$MR_GIT_REMOTE_BRANCH" ]; then
            branch_opt="-b $MR_GIT_REMOTE_BRANCH"
            echo "Default remote branch is $MR_GIT_REMOTE_BRANCH"
        fi
        git clone $remote_opt $branch_opt "$1" "$MR_REPO"
        git_email "${2-$MR_NAME}"
    }
    github_clone () {
        MR_GIT_REMOTE=github
        MR_GIT_REMOTE_BRANCH=master
        git_clone `github_url "$@"`
    }
    git_clone_my_repo () {
        check_repo_name
        MR_GIT_REMOTE=arctic
        MR_GIT_REMOTE_BRANCH=master
        if work_repo; then
            email=
        else
            email="${MR_EMAIL:-dotfiles}"
        fi
        git_clone "$GIT_MY_UPSTREAM/${MR_REPO##*/}" "$email"
    }
    #
    moosehall_git_checkout () {
        if [ $# = 0 -o $# -gt 2 ]; then
            error "Usage: moosehall_git_checkout HUB-HOST [REPO]"
        fi
        hub="$1"
        repo="${2:-${MR_REPO#$HOME/}}"
        read_localhost_nickname
        if [ "$hub" = "$localhost_nickname" ]; then
            if ! [ -d "$MR_REPO" ]; then
                error "This machine is supposed to be the hub for $MR_REPO but it didn't exist!"
            fi
        else
            MR_GIT_REMOTE=$hub
            MR_GIT_REMOTE_BRANCH=master
            git_clone $hub:$repo
        fi
    }
    #
    savannah_ro_url () {
        echo "git://git.sv.gnu.org/${1:-$MR_NAME}.git"
    }
    savannah_rw_url () {
        echo "ssh://aspiers@git.sv.gnu.org/srv/git/${1:-$MR_NAME}.git"
    }
    github_url () {
        echo "git@github.com:aspiers/${1:-${GITHUB_NAME:-$MR_NAME}}.git"
    }
    arctic_url () {
        echo "${GIT_MY_UPSTREAM_HOME}$repo"
    }
    #
    savannah_ro_remote () {
        git_add_remotes savannah `savannah_ro_url`
    }
    savannah_rw_remote () {
        git_add_remotes savannah `savannah_rw_url`
    }
    github_remote () {
        git_add_remotes github `github_url`
    }
    arctic_remote () {
        git_add_remotes arctic `arctic_url`
    }
    moosehall_remotes () {
        if not_moosehall; then
            return 0
        fi
        repo="${MR_REPO#$HOME/}"
        # Note: uses URL rewriting so we can decide independently
        # whether to fetch over wired/wireless or even ADSL.
        git_add_remotes "
        atlantic   atlantic:$repo
        southern   southern:$repo
        adriatic   adriatic:$repo
        mc      mediacentre:$repo
        "
    }
    public_repo_remotes () {
        moosehall_remotes && arctic_remote && github_remote
        fix_upstream
    }
    private_repo_remotes () {
        moosehall_remotes && arctic_remote
        fix_upstream
    }
    work_remotes () {
        repo="${MR_REPO#$HOME/}"
        arctic_remote
        git_add_remotes "
        atlantic   atlantic:$repo
        southern   southern:$repo
        pacific    pacific:$repo
        indian     indian:$repo
        "
        fix_upstream
    }
    auto_remotes () {
        if work_repo; then
            work_remotes
        elif confidential_repo; then
            private_repo_remotes
        else
            public_repo_remotes
        fi
    }
    #
    switch_from_origin_to () {
        local remote="$1"
        local upstream="$remote/$remote_branch"
        if ! git rev-parse "$upstream" >/dev/null 2>&1; then
            echo "$upstream is not tracked locally; fetching from $remote ..."
            ggf "$remote"
        else
            echo "Already tracking $upstream"
        fi
        ggsup "$upstream"
    }
    maybe_switch_from_origin_to () {
        # Return true (0) if the switch was made
        local remote="$1"
        if [ -z `git config "remote.$remote.url"` ]; then
            mr remotes
        else
            echo "$remote remote already set up"
        fi
        #
        if [ -n `git config "remote.$remote.url"` ]; then
            switch_from_origin_to "$remote"
            return 0
        else
            echo "'mr remotes' did not configure $remote remote; nothing to do."
        fi
        return 1
    }
    fix_upstream () {
        if [ -n "$upstream_fixed" ]; then
            return 0
        fi
        head=`git head`
        upstream=`git upstream`
        remote="${upstream%/*}"
        remote_branch="${upstream#*/}"
        if [ "$remote" != 'origin' ]; then
            echo "Current upstream is $upstream; nothing needs fixing."
            upstream_fixed=yes
            return 0
        fi
        origin_url=`git config "remote.origin.url"`
        switched_from_origin=
        if [[ "$origin_url" == ssh://adamspiers.org/home/adam/.GIT/adamspiers.org/* ]] ||
           [[ "$origin_url" == ssh://git.adamspiers.org/home/adam/.GIT/adamspiers.org/* ]]
        then
            if maybe_switch_from_origin_to 'arctic'; then
                switched_from_origin=yes
            fi
        elif [[ "$origin_url" == git@github.com:aspiers/$MR_NAME.git ]]; then
            if maybe_switch_from_origin_to 'github'; then
                switched_from_origin=yes
            fi
        else
            echo "Not touching upstream $upstream with URL $origin_url"
        fi
        if [ -n "$switched_from_origin" ]; then
            echo "Upstream switched from origin"
            if git remote rm origin; then
                echo "Removed origin remote"
            else
                return 1
            fi
        fi
        upstream_fixed=yes
    }
    #
    unsafe () {
        echo "Automatic $MR_ACTION via mr has been specified as unsafe for $MR_REPO"
    }

ge = git_email "$@"

git_update = git pull --ff-only "$@"
git_merge  = git pull "$@"
git_rebase = git pull -r "$@"
git_branch = ggb | grep '^\*'

git_wtf = git -c color.wtf=true wtf

git_wip_is_interactive = false
git_wip =
    if git wip; then
        #echo -e "\e[1m${MR_REPO/$HOME/~}\e[0m"
        echo "TODO: git sync-upstream in $MR_REPO"
        ggs
        #echo
        #exit 1
    fi

git_dwim =
    if git wip; then
        git-dwim
    fi

forceremotes = MR_OVERWRITE_REMOTES=y mr remotes "$@"

# Try to avoid ambiguating 'fixups' or 'update' actions.
git_chkupstream = fix_upstream
