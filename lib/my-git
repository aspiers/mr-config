# -*- mode: sh -*-

lib =
    MR_GIT=$HOME/.GIT
    GIT_MY_ROOT=$MR_GIT/adamspiers.org
    GIT_MY_UPSTREAM=adamspiers.org:
    GIT_UPSTREAM_ROOT=$MR_GIT/3rd-party # not referenced yet
    #
    check_repo_name () {
        [ -n "$MR_NAME" ] || error "\$MR_NAME not set for $MR_REPO"
    }
    #
    git_email () {
        cd "$MR_REPO"
        if ! work_repo; then
            git_set_personal_email "$@"
            return 0
        fi
        #
        if [ -n "$1" ]; then
            error "Invoked 'git_email $1' on work repository $MR_REPO"
        fi
        git_set_email aspiers@suse.com
    }
    git_set_personal_email () {
        existing=$( git config user.email || true )
        # Don't overwrite dotfiles address with default.
        if [ -z "$1" -a "$existing" = 'dotfiles@adamspiers.org' ]; then
            info "Defaulting to existing address: <$existing>"
            return
        fi
        email="${1:-${MR_EMAIL:-$MR_NAME}}"
        case "$email" in
            *@*) ;;
            *) email="$email@adamspiers.org"
        esac
        git_set_email "$email"
    }
    git_set_email () {
        email="$1"
        existing=$( git config user.email || true )
        if [ "$email" != "$existing" ]; then
            git config user.email "$email"
            info "Set user.email from ${existing:-(none)} to $email"
        fi
    }
    # Usage: git_clone URL [EMAIL]
    # EMAIL defaults to MR_EMAIL if set, otherwise a sensible value
    # is guessed (see above).
    git_clone () {
        check_repo_name
        info "Cloning from $1"
        remote_opt=
        if [ -n "$MR_GIT_REMOTE" ]; then
            remote_opt="-o $MR_GIT_REMOTE"
            info "Default remote is $MR_GIT_REMOTE"
        fi
        branch_opt=
        if [ -n "$MR_GIT_REMOTE_BRANCH" ]; then
            branch_opt="-b $MR_GIT_REMOTE_BRANCH"
            info "Default remote branch is $MR_GIT_REMOTE_BRANCH"
        fi
        git clone $remote_opt $branch_opt "$1" "$MR_REPO"
        git_email "$2"
    }
    github_clone () {
        MR_GIT_REMOTE=github
        MR_GIT_REMOTE_BRANCH=master
        git_clone `github_url "$@"`
    }
    savannah_ro_clone () {
        MR_GIT_REMOTE=savannah
        MR_GIT_REMOTE_BRANCH=master
        git_clone `savannah_ro_url "$@"`
    }
    git_clone_my_repo () {
        check_repo_name
        MR_GIT_REMOTE=adamspiers.org
        MR_GIT_REMOTE_BRANCH=master
        if work_repo; then
            email=
        else
            email="${MR_EMAIL:-dotfiles}"
        fi
        git_clone `my_upstream_url` "$email"
    }
    #
    moosehall_git_checkout () {
        if [ $# = 0 -o $# -gt 2 ]; then
            error "Usage: moosehall_git_checkout HUB-HOST [REPO]"
        fi
        hub="$1"
        repo="${2:-${MR_REPO#$HOME/}}"
        read_localhost_nickname
        if [ "$hub" = "$localhost_nickname" ]; then
            if ! [ -d "$MR_REPO" ]; then
                error "This machine is supposed to be the hub for $MR_REPO but it didn't exist!"
            fi
        else
            MR_GIT_REMOTE=$hub
            MR_GIT_REMOTE_BRANCH=master
            git_clone $hub:$repo
        fi
    }
    #
    savannah_ro_url () {
        echo "git://git.sv.gnu.org/${1:-$MR_NAME}.git"
    }
    savannah_rw_url () {
        echo "ssh://aspiers@git.sv.gnu.org/srv/git/${1:-$MR_NAME}.git"
    }
    github_url () {
        echo "git@github.com:aspiers/${1:-${MR_GITHUB_NAME:-$MR_NAME}}.git"
    }
    my_upstream_url () {
        echo "${GIT_MY_UPSTREAM}${MR_REPO##*/}.git"
    }
    #
    savannah_ro_remote () {
        git_add_remotes savannah `savannah_ro_url`
    }
    savannah_rw_remote () {
        git_add_remotes savannah `savannah_rw_url`
    }
    github_remote () {
        git_add_remotes github `github_url`
    }
    my_upstream_remote () {
        git_add_remotes adamspiers.org `my_upstream_url`
    }
    moosehall_remotes () {
        if not_moosehall; then
            return 0
        fi
        repo="${MR_REPO#$HOME/}"
        # Note: uses URL rewriting so we can decide independently
        # whether to fetch over wired/wireless or even ADSL.
        git_add_remotes "
        atlantic    atlantic:$repo
        southern    southern:$repo
        adriatic    adriatic:$repo
        pacific      pacific:$repo
        indian        indian:$repo
        mc       mediacentre:$repo
        "
    }
    public_repo_remotes () {
        moosehall_remotes && my_upstream_remote && github_remote
        fix_upstream
    }
    private_repo_remotes () {
        moosehall_remotes && my_upstream_remote
        fix_upstream
    }
    work_remotes () {
        repo="${MR_REPO#$HOME/}"
        my_upstream_remote
        git_add_remotes "
        atlantic   atlantic:$repo
        southern   southern:$repo
        pacific    pacific:$repo
        indian     indian:$repo
        "
        fix_upstream
    }
    auto_remotes () {
        if work_repo; then
            work_remotes
        elif confidential_repo; then
            private_repo_remotes
        else
            public_repo_remotes
        fi
    }
    #
    fetch_and_switch_upstream_to () {
        # Return true (0) iff the switch was made
        local remote="$1"
        local upstream="$remote/$remote_branch"
        if ! git rev-parse "$upstream" >/dev/null 2>&1; then
            info "$upstream is not tracked locally; fetching from $remote ..."
            if ! ggf "$remote"; then
                return 1
            fi
        else
            info "Already tracking $upstream"
        fi
        ggsup "$upstream"
    }
    configure_upstream_and_switch_to () {
        # Return true (0) if the switch was made
        local remote="$1"
        #
        if [ -z `git config "remote.$remote.url"` ]; then
            mr remotes
        else
            echo "$remote remote already set up"
        fi
        #
        if [ -n `git config "remote.$remote.url"` ]; then
            if fetch_and_switch_upstream_to "$remote"; then
                return 0
            fi
        fi
        info "'mr remotes' did not configure $remote remote; nothing to do."
        return 1
    }
    fix_upstream () {
        if [ -n "$upstream_fixed" ]; then
            info "upstream already fixed in this run; won't fix again."
            return 0
        fi
        head=`git head`
        upstream=`git upstream`
        remote="${upstream%/*}"
        remote_branch="${upstream#*/}"
        if [ "$remote" != 'origin' ]; then
            echo "Current upstream is $upstream; nothing needs fixing."
            upstream_fixed=yes
            return 0
        fi
        origin_url=`git config "remote.origin.url"`
        switched_from_origin=
        case "$origin_url" in
            ssh://adamspiers.org/home/adam/.GIT/adamspiers.org/* | \
            ssh://git.adamspiers.org/home/adam/.GIT/adamspiers.org/* | \
            ssh://adam@git.adamspiers.org/home/adam/.srv/git/*)
                if configure_upstream_and_switch_to 'adamspiers.org'; then
                    switched_from_origin=yes
                fi
                ;;
            git@github.com:aspiers/$MR_NAME.git)
                if configure_upstream_and_switch_to 'github'; then
                    switched_from_origin=yes
                fi
                ;;
            *)
                info "Not touching upstream $upstream with URL $origin_url"
                ;;
        esac
        if [ -n "$switched_from_origin" ]; then
            info "Upstream switched from origin"
            if git remote rm origin; then
                info "Removed origin remote"
            else
                return 1
            fi
        fi
        upstream_fixed=yes
    }
    #
    unsafe () {
        warning "Automatic $MR_ACTION via mr has been specified as unsafe for $MR_REPO"
    }

ge = git_email "$@"

git_update = git pull --ff-only "$@"
git_merge  = git pull "$@"
git_rebase = git pull -r "$@"
git_branch = ggb | grep '^\*'

git_wtf = git -c color.wtf=true wtf

git_wip_is_interactive = false
git_wip =
    if git wip; then
        #echo -e "\e[1m${MR_REPO/$HOME/~}\e[0m"
        warning "TODO: git sync-upstream in $MR_REPO"
        ggs
        #echo
        #exit 1
    fi

git_dwim =
    if git wip; then
        git-dwim
    fi

forceremotes = MR_OVERWRITE_REMOTES=y mr remotes "$@"

# Try to avoid ambiguating 'fixups' or 'update' actions.
git_chkupstream = fix_upstream
